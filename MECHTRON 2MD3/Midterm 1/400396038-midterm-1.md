# Midterm 1

## Question 1

**Reverse Polish Notation** (also known as postfix notation) is an unambiguous way of writing an arithmetic expression without parentheses. It is defined so that if $(exp1) * (exp2)$ is a normal fully parenthesized expression whose operation is $*$, then the postfix version of  this is "pexp1 pexp2∘", where pexp1 is the postfix version of exp1 and pexp2 is the postfix version of exp2. The postfix version of a single number or variable is just that number or variable. So, for example, thepostfix version of "((5 + 2) * (8 − 3))/4" is "5 2 + 8 3 − * 4 /". Write a program that uses a stack for evaluating an expression in postfix notation. Wherever possible, you should use the object-oriented design patterns discussed in class. You must implement:

+ A class named Stack that implements the stack ADT.
+ An RPNEvaluator class that uses your Stack class.
+ Your program must use this main method:

```cpp
int main() {
    std::string rpn_exp;
    std::cout << "Please enter an expression in RPN format: ";
    std::getline(std::cin, rpn_exp);
    RPNEvaluator rpn(rpn_exp);
    rpn.Evaluate();
    return EXIT_SUCCESS;
}

Example input: 5 2 + 8 3 − * 4 /
Expected output: Answer: 8.75

```

Each part of the input expression is separated by one or more spaces, and you can expect input to contain only integers and operators.


You must handle the following operators: + - * / If the input expression is malformed or contains input other than integers and operators, your program should output this string “Error: malformed expression”

---

## Question 2
>Al and Bill are arguing about the performance of their sorting algorithms. Al claims that his O(n log n)-time algorithm is always faster than Bill’s O(n2)-time algorithm. To settle the issue, they implement and run the two algorithms on many randomly generated data sets. To Al’s dismay, they find that if n < 100 the O(n2)-time algorithm actually runs faster, and only when n ≥ 100 the O(n log n)-time one is better. Explain why the above scenario is possible. You may give numerical examples

<p align="center">
  <img src="https://i.imgur.com/F8FesL4.png" />
</p>

In big O(n) notation, the general idea is that as $\lim\limits_{n\to\infty}$ all constants are ignored since a constant*$\infty$ is simply $\infty$. In Al's cause since we are dealing with very small n numbers ($<100$) any constant in front of $$a*n^2$$ <p align="center"> or</p> $$b*nlog(c
*n)$$


where each value of a, b, or c would have a significant effect on n<100. In the example above, when a is <0.02, Bill's graph would have a lower runtime when n<100 but a larger one when n>100.


## Question 3

Implement a capacity-limited version of the deque ADT based on a vector used in a circular fashion. Your class should be called Deque and support the following methods. It will store std::string elements

+ Deque(int n): Construct a deque with capacity n.
+ insertFront(std::string e): Inserts a new element e at the beginning of the deque.
+ insertBack(std::string e): Inserts a new element e at the end of the deque.
+ eraseFront(): Removes the first element of the deque (if it is not empty)
+ eraseBack(): Removes the last element of the deque (if it is not empty)
+ front(): Returns the first element of the deque. If the deque is empty, the string
“error: empty deque” is returned.
+ back(): Returns the last element of the deque; If the deque is empty, the string
“error: empty deque” is returned.
+ size(): Return the number of elements in the deque.
+ empty():Return true if the deque is empty and false otherwise.


Your class must be called “Deque” and it must include the above methods with those
exact names. You will need to design your own main method to test your Deque, but
your submission must NOT include a main method.


## Question 4 

Write a single tail recursive C++ function that will rearrange
a vector of int values so that all the even values appear before all the odd values.

```cpp
std::vector<int> recursiveSeparator(std::vector<int> vec, int index){
 cout << index <<endl;
  if (index == vec.size()){
    return vec;
  }
  for(int i = index +1;i<vec.size();i++){
    if (vec[index] % 2 == 1){ //if number is odd
      if (vec[i] % 2 == 0){
          int temp = vec[index];
          vec[index] = vec[i];
          vec[i] = temp;
      }
    }
  }
  return recursiveSeparator(vec, index+1);
}
```

## Question 5
Show by counterexample that the following statement is false: For any positive constant c, f(cn) = O(f(n))

+ Constant 
  + 1, for any constant $c*1$ the big O notation value as n goes towards infinity would still be $c*1$ since as $\lim\limits _{n\to\infty}$ the constant value would not change or drop.
+ Linear 
  + n
+ Logarithmic 
  + n log n
+ Quadratic 
  + $n^2$
+ Exponential 
  + $2^n$
+ Factorial
  + n!

## Question 6

> Part 1: Suppose it is known that the running time of an algorithm is (1/3)n2 + 6n, and that the running time of another algorithm for solving the same problem is 111n − 312. Which one would you prefer, assuming all other factors equal? 

For the two algorithms O($n^2/3+6n$) and O($111n - 312$), when considering big O notation as $\lim\limits _{n\to\infty}$ they would simplify to O($n^2$) and O($n$). It would almost always be better to use the O($n$) algorithm (111n − 312) as for most cases it would be faster and more efficient for larger sample sizes. Looking at the graph below, the only times the (1/3)n2 + 6n algoritm is faster is when n<3 which in most algoritms is irrelevant. 

<p align="center">
  <img src="https://i.imgur.com/apVGpar.png" />
</p>

Part 2: Of course, “all other factors” are never exactly equal for two algorithms. There is no question that execution time is important, but there are other factors to consider when choosing an algorithm. Can you think of other considerations ? (Provide 3 other considerations for full marks)

1. A lot of devices that use C/C++ are microcontroller or smaller devices where the programmer has to consider the maximum memeory usage a device has to offer for a given algorithm. An algorithm with a execelent time complexity does not mean that it will have a good space complexity as well. 
2. Another factor to consider is how approachable the function is to for other developers in the workplace. A function with $n*log(2^{ln(n^3)})$ would be much more complex and difficult to implement in other areas or to fix when maintaining certain code. This is because although a alternate algorithm with for example $n*log(n^3)$ time would be worse for bigger n values, it might be more intuitive to use for others.
3. Lastly another factor to consider is how error-proof an algorthm is for unexpected inputs, edge cases, or security risks. Often times when working with user inputted values accounting for such errors can cause a program to be more secure but less efficient in terms of big O time. 