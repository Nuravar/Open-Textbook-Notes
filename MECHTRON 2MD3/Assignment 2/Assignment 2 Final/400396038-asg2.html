<!DOCTYPE html>
<html>
<head>
<title>400396038-asg2.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="mechtron-2md3--assignment-2">MECHTRON 2MD3 | Assignment 2</h1>
<h2 id="question-1">Question 1</h2>
<blockquote>
<p>Describe in detail how to swap two nodes <code>x</code> and <code>y</code> (and not just their contents) in a singly linked list L given references only to <code>x</code> and <code>y</code>. You can assume that you also have a reference to the <code>head</code> of the singly linked list, and to the header and trailer for the doubly linked list. No assumptions can be made about the relative location of nodes <code>x</code> and <code>y</code> in the list. Repeat this exercise for the case when L is a doubly linked list. Which algorithm takes more time?</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-comment">//using the structure</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span>
    <span class="hljs-keyword">int</span> data;
    Node* next;
};
</div></code></pre>
<p>To swap two nodes in a singly-linked list, you would do the following steps:</p>
<ol>
<li>Lets say that you are given the following structure in the function call:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    swapNodes(head, x, y) <span class="hljs-comment">//where head, x, and y are addresses</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<ol start="2">
<li>
<p>Then in the swap function you would create a while loop that goes through the entire linked list to find the positions of x and y starting from head.</p>
</li>
<li>
<p>With the positions of x and y, to swap the two nodes you would have to change 4 things:</p>
<ul>
<li><code>x-&gt;next</code> value</li>
<li><code>x-&gt;prev-&gt;next</code> value</li>
<li><code>y-&gt;next</code> value</li>
<li><code>y-&gt;prev-&gt;next</code> value</li>
</ul>
</li>
<li>
<p>What these values would be is:</p>
<ul>
<li><code>x-&gt;next</code> = <code>y-&gt;next</code></li>
<li><code>x-&gt;prev-&gt;next</code> = <code>y</code></li>
<li><code>y-&gt;next</code> = <code>x-&gt;next</code></li>
<li><code>y-&gt;prev-&gt;next</code> = <code>x</code></li>
</ul>
</li>
<li>
<p>To do this you would have to check if x and y are the same address, if they are then you would do nothing.</p>
</li>
<li>
<p>First you would use a while loop to search for an address that is the same as the address of x</p>
</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">//the following is pseudocode</span>
Node *prevX = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//the address of prevX</span>
Node *currX = *head; 
<span class="hljs-keyword">while</span> address of currX != x {
    prevX = currX;
    currX = currX-&gt;next;
}
<span class="hljs-comment">//when this while loop stops we are left with curr=x and prevX = x-&gt;prev</span>

<span class="hljs-comment">//the same code above would be repeated for node y</span>
Node *prevY = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//the address of prevX</span>
Node *currY = *head; 
<span class="hljs-keyword">while</span> address of currY != y {
    prevY = currY;
    currY = currY-&gt;next;
}
</div></code></pre>
<ol start="7">
<li>Now we are left with the addresses of <code>prevX</code>, <code>x</code>, <code>prevY</code>, and <code>y</code></li>
<li>Now assume that x and y exist and that they are not the head of the list. You would simply just:</li>
</ol>
<pre class="hljs"><code><div>prevX-&gt;next = currY;

prevY-&gt;next = currX;

Node *temp = currX-&gt;next;
currX-&gt;next = currY-&gt;next;
currY-&gt;next = temp;

</div></code></pre>
<ol start="9">
<li>Else if x or y is the head, you would:</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-comment">// if x is the head of the list, instead of prevX-&gt;next = currY</span>
*head = currY;
<span class="hljs-comment">// if y is the head of the list, instead of prevY-&gt;next = currX</span>
*head = currX;
</div></code></pre>
<p>For a doubly-linked list, the process would be simpler as you do not have to save the value of the prev pointer. You would first check if x or y is the head of the list.</p>
<ul>
<li>If x is the head of the list or the tail then the you would set y as the head or the tail respectively. The vice-versa also applies to if y is the head or the tail.</li>
</ul>
<p>Then what you would do is:</p>
<pre class="hljs"><code><div><span class="hljs-comment">//asumming that you checked if x and y exist</span>
Node *temp = <span class="hljs-literal">NULL</span>;
temp = x-&gt;next;
x-&gt;next = y-&gt;next; 
y-&gt;next = temp; 
<span class="hljs-comment">//then assuming that x-&gt;next and y-&gt;next is not NULL due to being tail</span>
x-&gt;next-&gt;prev = x; <span class="hljs-comment">//since y-&gt;next-&gt;prev would still be y</span>
y-&gt;next-&gt;prev = y; <span class="hljs-comment">//since x-&gt;next-&gt;prev would still be x</span>
<span class="hljs-comment">//then to swap the previous </span>
temp = x-&gt;prev;
x-&gt;prev = y-&gt;prev;
y-&gt;prev = temp;
<span class="hljs-comment">//and finally if x-&gt;prev and y-&gt;prev is not NULL due to being head</span>
x-&gt;prev-&gt;next = x <span class="hljs-comment">//since x-&gt;prev-&gt;next would still be y</span>
y-&gt;prev-&gt;next = y
</div></code></pre>
<p>The above steps would result in swapping two nodes in a doubly linked list. Now in terms of the time usage by both algorithms the swapping nodes for the singly linked list would take more time as you would have to use a while loop to find the <code>prev</code> values while in a doubly-linked list you would just take the points using <code>x-&gt;prev</code></p>
<h2 id="question-2">Question 2</h2>
<blockquote>
<p>Draw the recursion trace for the execution of function ReverseArray(A,0,4) (Code Fragment 3.39 in Goodrich text) on array A={4,3,6,2,5}</p>
</blockquote>
<pre class="hljs"><code><div><span class="hljs-function">Algorithm <span class="hljs-title">ReverseArray</span><span class="hljs-params">(A, i, j)</span>:
    Input: An <span class="hljs-built_in">array</span> A <span class="hljs-keyword">and</span> nonnegative integer indices i <span class="hljs-keyword">and</span> j
    Output: The reversal of the elements in A starting at index i <span class="hljs-keyword">and</span> ending at j
    <span class="hljs-keyword">if</span> i &lt; j then: 
        Swap A[i] <span class="hljs-keyword">and</span> A[ j]
        <span class="hljs-title">ReverseArray</span><span class="hljs-params">(A, i+<span class="hljs-number">1</span>, jâˆ’<span class="hljs-number">1</span>)</span>
    <span class="hljs-keyword">return</span>
</span></div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ReverseArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* A, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span></span>{
    <span class="hljs-keyword">if</span>(i &lt; j) {
        <span class="hljs-keyword">int</span> temp = A[i];
        A[i] = A[j];
        A[j] = temp;
        ReverseArray(A, i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[] = {<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>};
    ReverseArray(<span class="hljs-built_in">array</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">array</span>)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>); i++){
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">array</span>[i] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    } 
}
</div></code></pre>
<p>Utilizing this code as a reference, the recursion trace for the recursion trace of the function <code>ReverseArray</code> for index <code>A(0,4)</code> would be:</p>
<p align="center">
  <img src="https://i.imgur.com/kxA2gTy.png" />
</p>

</body>
</html>
